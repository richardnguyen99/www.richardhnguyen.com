---
title: 'The Backbone of Internet: TCP'
slug: 'the-backbone-of-internet-tcp'
date: '2025-03-11'
published: false
publishedAt: '2025-03-11'
author: 'Richard H. Nguyen'
tags:
  - 'tcp'
  - 'network'
category: 'computer-network'
thumbnail: '/thumbnails/tcp.png'
changeLog:
  -
    date: '2024-09-30'
    changes:
      - 'Initial post'
  -
    date: '2025-03-11'
    changes:
      - 'Write the post'
---

Transmission Control Protocol (TCP) is one of the core protocols of the
Internet Protocol Suite. TCP provides reliable, ordered, and error-checked
delivery of content between two endpoints. It is the backbone of the Internet
and is used by many applications like web browsing, email, and file transfer.

{/* EXCERPT */}

# Introduction

TCP is one of the standard network protocols that define our modern Internet.
85% of total Internet traffic is TCP traffic[^1], while the rest is UDP traffic.
It was developed in the 1970s by
[Vint Cerf](https://www.internethalloffame.org/vint-cerf/) and
[Robert Kahn](https://www.internethalloffame.org/inductee/robert-kahn/)
to buildd a reliable client-server communication using
[packet-switching](https://ethw.org/Packet_Switching).

> Packet switching is a method of data transmission in which data is broken into
> small packets and sent over a network. Instead of establishing a dedicated
> connection line between two hosts, packet switching allows smaller packets to
> be sent independently on multiple routes and reassembled at the destination.

TCP is a connection-oriented, reliable, and stream-oriented protocol. It
provides many mechanisms to ensure the reliability of data transmission such as
error detection, retransmission, duplication, flow controls and congestion
controls.

Most of TCP applications are web-based applications like HTTP (HTTP/1.1 and
HTTP/2), HTTPS, FTP and SMTP, which are basically the protocols that run servers
and applications used by billions of people globally.

# What is TCP?

TCP is a protocol in the Transport Layer of the Internet Protocol Suite. The job
of the Transport Layer is to provide a logical communication between _application processes_. Transport Layer is implemented on top of the Network
Layer and below the Application Layer.

TCP and UDP are the two most common transport protocols. They are both
implemented by the operating systems in the endpoint devices such as computers,
smartphones, and servers whereas the Network Layer is implemented by the
routers and switches and the Application Layer is implemented by the
applications such as web browsers, and web servers.

> If you are not familiar with the network model, I have a post that explains it
> using a postal service analogy. You can read it
> [here](/blogs/understand-the-network-protocol-stacks-with-analogy).

As mentioned above, TCP is a reliable protocols for transferring data between
two endpoints. But why do we need a reliable protocol? Can we just send the data
and the other end will receive it? Well, it's not the simple. There are
many situations the can cause the data to be lost or corrupted during the
transmission. TCP is designed to handle these situations, ensure that the data is transferred correctly and in the right order.

## Connection-oriented protocol

TCP is a connection-oriented protocol because in order to transfer data, both
endpoints must establish a dedicated communication path before sending or
receiving any data. This is done by a process called
[three-way handshake](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment).

```mermaid
sequenceDiagram
    autonumber
    participant client
    participant server


    critical TCP establish from client
        client->>+server: (TCP) Send SYN
        server-->>-client: (TCP) send SYN & ACK
        client->>server: (TCP) Send ACK

        Note over client,server: Threeway handshake completed
    end

    client->>+server: Hello!
    server-->>-client: Hi!

    client->>+server: How are you?
    server-->>-client: I'm fine.<br/>And you?

    client->>+server: I'm good.
    server-->>-client: Good to hear!

    Note over client,server: Any data can be sent with<br />a reliable connection


    critical TCP close from server
        server->>+client: (TCP) Send FIN
        client-->>server: (TCP) send ACK
        client-->>-server: (TCP) send FIN
        server->>client: (TCP) send ACK

        Note over client,server: Threeway handshake completed
    end
```

To understand the connection-mode of TCP, you should consider how connectionless
protocols like UDP and IP work. UDP wraps the data in a packet, called
_datagram_, and sends it to the destination without any prior. It follows the
principle of "Fire and Forget". The sender does not care if the packet is
delivered or not. If it needs a response, it will either wait, send another
packet or respond back to the user.

TCP establishes a connection between two endpoints before transferring any data.
This connection will detect data corruption, correct errors and retransmit lost
data. It also ensures that the data is delivered in the same order as it was
sent.

## Stream-oriented protocol

TCP is a stream-oriented protocol. It means that it provides a continuous
stream of data between two endpoints. The data is divided into smaller chunks
called _segments_ and each segment is assigned a sequence number. The receiver
reassembles the segments in the correct order based on the sequence numbers.

For example, if the sender sends three segments with sequence numbers 1, 2 and
3, the receiver will receive them in the same order and reassemble them into
a continuous stream of data. The receiver will also send an acknowledgment
(ACK) packet to the sender to confirm that the segments are received correctly.

```mermaid
sequenceDiagram
    autonumber
    participant client
    participant server

    Note over client,server: Client sends a stream of data to the server

    client->>+server: (TCP) Send segment 1
    client->>+server: (TCP) Send segment 2
    client->>+server: (TCP) Send segment 3

    Note over client,server: Server receives the segments and reassembles<br />them into a continuous stream of data

    server-->>-client: (TCP) send ACK for segment 1
    server-->>-client: (TCP) send ACK for segment 2
    server-->>-client: (TCP) send ACK for segment 3

    Note over client,server: Client receives the ACK packets and<br />knows that the segments are received correctly
```

The following figure illustrates how TCP provides a continuous stream of data
between two endpoints. The sender sends a stream of data to the receiver and
the receiver reassembles the data into a continuous stream. The sender and
receiver use sequence numbers to keep track of the segments and ensure that
the data is delivered in the right order.

## Reliable data transfer

TCP is built on top of the unreliable IP protocol. IP does not guarantee that
the data is delivered. It follows the principle of "Best Effort", i.e _"I try my
best but I don't promise anything"_. Due to physical factors, data can be
corrupted with bit flipping. And when you move higher to the architecture of the
Internet, data can be lost due to many reasons such as delay, network congestion
or simply the destination is unreachable.

For example, in a busy network, packets can be dropped due to congestion. In the
following figure, packet 1 and packet 3 got transferred successfully but packet
2 got dropped because host D is facing a congestion in its network.

![Packet Loss](/packet-loss.png "Packet Loss")

TCP provides many mechanisms to ensure that the data is transferred in whole and
in the right order. Not only that, TCP can detect and control the congestion
in the host and in the network with *flow control* and *congestion control*
mechanisms respectively.

# How TCP works

TCP is a complex protocol because it has to handle many different situations
that can occur during data transmission and cause data loss or corruption. TCP
provides many mechanisms to ensure the reliability of data transmission such as
error detection, retransmission, duplication, flow controls and congestion
controls.

## TCP structure

IP protocol is an unreliable protocol. It folows a simple principle _"Best
Effort"_. It sends the data to the destination without any guarantee that the
data is delivered. TCP is designed to provide a reliable data transfer.

As discussed above, TCP is a transport-layer protocol between application layer
and the network layer. TCP works by wrapping the data sent by the application
into a packet with TCP fields. A complete TCP packet with application data
and TCP fields is called a **TCP segment**. The TCP segment is then passed to
the network layer to be encapsulated into an IP packet and IP protocol will
deliver this packet to lower layers of the network stack.

TCP packet typically looks like this:

```mermaid
---
title: "TCP Packet"
---
packet-beta
0-15: "Source Port"
16-31: "Destination Port"
32-63: "Sequence Number"
64-95: "Acknowledgment Number"
96-99: "Data Offset"
100-105: "Reserved"
106: "URG"
107: "ACK"
108: "PSH"
109: "RST"
110: "SYN"
111: "FIN"
112-127: "Window"
128-143: "Checksum"
144-159: "Urgent Pointer"
160-191: "(Options and Padding)"
192-255: "Data (variable length)"
```

Now let's break down the structure of a TCP packet:

- **Source Port**: The port number of the application that sends the data.
- **Destination Port**: The port number of the application that receives the
  data.
- **Sequence Number**: The sequence number of the first byte of data in the
  packet. This is used to build a reliable data transfer protocol as discussed
  below.
- **Acknowledgment Number**: The sequence number of the next byte of data that
  the sender expects to receive. This is used to acknowledge the receipt of
  data.
- **Data Offset**: The size of the TCP header in 32-bit words. This is used to
  determine the length of the TCP header.
- **Option field**: This field is used to specify optional parameters for the
  TCP connection. It can be used to set the maximum segment size, window scale,
  and other options.
- **Window size**:  The size of the receive window. This is used to control the
  flow of data between the sender and receiver. It is used in flow control and
  congestion control (discussed below).
- **Checksum**: A 16-bit checksum used to detect errors in the TCP header and
  data. The sender computes the checksum of the TCP header and data and sends it
  to the receiver. The receiver computes the checksum of the received TCP
  header and data and compares it with the checksum sent by the sender. If the
  checksums match, the data is considered to be correct. If the checksums do not
  match, the data is considered to be corrupted and the receiver will discard
  the data.
- **Urgent Pointer**: This field is used to indicate the end of the urgent data
  in the TCP segment. Urgent data is data that should be processed immediately,
  such as a keyboard interrupt. However, this field is not used in modern TCP
  implementations.
- **Flag fields**: These fields are used to mark the TCP packet with different
  control flags. The most common flags are:
  - **URG**: Urgent pointer field significant
  - **ACK**: Acknowledgment field significant
  - **PSH**: Push function
  - **RST**: Reset the connection
  - **SYN**: Synchronize sequence numbers
  - **FIN**: No more data from sender
- **Data**: The application data that is being sent. This is the payload of the
  TCP packet. The size of the data field is variable and depends on the size of
  the application data.

To imagine how network packets work, you can think of it's an onion. When an
application process wants to send a message to another application process, it
will construct the message, as the core of the onion. TCP receives the message,
wraps it in a TCP packet as the first layer of the onion. Then, the IP protocol
will wrap the TCP packet in an IP packet as the second layer of the onion. As
the packet moves down the network and gets sent through the internet, the
receiver end then peals off the layers one by one until it reaches the core of the onion, which is the original application message.

![Network Overview](/network-overview.png "Network Overview")

## TCP construction

As mentioned above, TCP is a stream-oriented protocol. It views data as an
unstructured but ordered stream of bytes. On sending a large file, the sender
will break the file into smaller chunks of data, called _segments_.

![TCP Stream Orientation](/tcp-stream-orientation.png "TCP Stream Orientation")

Each segment is assigned a sequence number. The sequence number for a segment
is the byte-stream number of the first byte in the segment. For example, if Host
A sends a file, whose size is 9216 bytes, to Host B. The **maximum segment size
(MSS)** is 3072 bytes. The file will be divided into 3 segments, each of which
has 3072 bytes. The first segment will have a sequence number of 0, the second
segment will have a sequence number of 3072 and the third segment will have a
sequence number of 6144.

The acknowledgement (ACK) number is the sequence number of the next byte that
the receiver expects to receive. For example, if Host A sends a file to Host B
and Host B receives the first segment with a sequence number of 0 and a byte
size of 3072 (0-3071), Host B will send an ACK packet with an ACK number of 3072
to Host A to acknowledge that it has received the first segment correctly and
are expecting to received the next packet with a sequence number of 3072.

In practical situations, many subsequent segments can be lost or arrive out of
order. TCP is designed to handle these situations by utilizing the sequence
number and acknowledgement number. However, the original proposal of TCP did not
specify *HOW* and left the implementations to the developers. As a result,
there are many different implementations of TCP that are used in the real world.
But most of them are based on two main protocols and their variations:
[Go-Back-N (GBN)](#go-back-n) and [Selective Repeat (SR)](#selective-repeat).

## Error detection

The most basic mechanism of a reliable data transfer (RDT) protocol is the error
detection mechanism. Let's grant that all the data is delivered to the receiver
in the correct order. But how do we know that the data is not corrupted?

There are many factors that can cause the data to be corrupted. It could be a
hardware problem such as faulty network devices, power surge or improper
shutdown. It could also be a software problem due to wrong configuration on the
network stacks, outdated drivers, etc.

TCP uses a checksum to detect errors in the data. This checksum is computed at
the sender side and sent along with the data. The receiver computes the checksum
of the received data and compares it with the checksum sent by the sender. If
the checksums match, the data is considered to be correct. If the checksums do
not match, the data is considered to be corrupted and the receiver will discard
the data.

But here is the tricky part. How should the receiver tell the sender that the
data is corrupted? The sender will be wait for the ACK packet from the receiver
to confirm that the data is received correctly.

The receiver can send a negative acknowledgment (NAK or NACK) packet to the
sender to indicate that an error is detected. The sender will retransmit the
data.

![TCP Receiver Error Detection](/tcp-receiver-error-detection.png "TCP Receiver Error Detection")

After sending the data, the sender will wait for the response packet from the
receiver. If the sender receives an ACK packet, it means that the data is
received correctly. If the sender receives a NACK packet, it means that the data
is corrupted and the sender will retransmit the data.

![TCP Sender Error Detection](/tcp-sender-error-detection.png "TCP Sender Error Detection")

However, the NACK mechanism is not used in TCP directly. Instead, the receiver
treats the corrupted data as a packet loss; it will discard the corrupted data.


## Packet loss and Packet retransmission

Same as data corruption, packet loss is another most common problem when it
comes to building a reliable data transfer protocol. There are many factors that
can cause packet loss such as queue overflow, congestion or just simply business
rules.

TCP is designed to handle packet loss and retransmit the lost packets. When a
packet is sent, the sender will expect an acknowledgment (ACK) packet from the
receiver to confirm that the packet is arrived safely. If the sender does not
receive the ACK packet that matches the sequence number of the sent packet, it
will assume that the packet is lost. The sender will retransmit the packet.

TCP uses a time-based retransmission mechanism to retransmit the lost packets.
When a packet is sent, the sender starts a timer. If the timer expires before
the sender receives the ACK packet, it will retransmit the packet.

![TCP timer retransmission](/tcp-timer-retransmission.png "TCP timer retransmission")

> From the perspective of Host A, it does not know whether the packet is lost
> before arriving at Host B, the packet gets dropped at Host B, the ACK packet
> from Host B is lost or there is a unusual delay. In all cases, the timer will
> act as a trigger to retransmit the packet.

However, relying on the timer is not an efficient way to handle packet loss. In
a practical network, sending packets, even when they are likely to be lost, are
still faster than waiting for the timer to expire. You don't know how long it's
gonna take for the timer to expire so it tends to be set with a high value.

## Pipelining and out-of-order delivery

Pipelining is a technique that allows multiple packets to be sent before
waiting for the acknowledgment (ACK) of the previous packets. This technique
increases the throughput of the network because it allows the sender to send
more packets in a shorter amount of time. However, it also increases the
complexity of the protocol because the receiver can receive the packets in any
order. The receiver must be able to reassemble the packets in the correct order
before delivering the data to the application.

### Go-Back-N

**Go-Back-N (GBN)** protocol allows the sender to send multiple requests within
available number  without waiting for the an acknowledgment package. Combining
with a timer, the sender can retransmit the lost packets.

In order to handle multiple concurrent packets, GBN senders maintain a sliding
window to buffer outgoing and incoming packets. A sliding window is a range of
sequence numbers and acknowledgments (ACKs) that the sender and receiver use to
keep track of the packets that are sent and received. The sender  to maintain
one timer for the first sent-but-not-yet-ACK'd packet.

![TCP sliding window in sender](/tcp-sender-window.png "TCP sliding window in sender")

In the figure, the sender is expecting ACKs for packets `n`, `n+1`, and `n+2`
ACK packets. If the sender receives an ACK packet for packet `n`, it will
advance the window to the right and the timer will be reset until there is none
sent-but-not-yet-ACK'd packets.

The sender uses the timer to keep track of the first ACK packet in the window.
If the timer expires, the sender will retransmit all the packets.

![TCP GBN retransmission](/tcp-gbn-retransmission.png "TCP GBN retransmission")

On the receiver side, its job is to keep the order of the received packets. The
receiver maintains a global next-expected sequence number. When the receiver
receives a packet with the expected sequence number, it will deliver the data to
the application and send an ACK packet to the sender. If the receiver receives a
packet with a sequence number that is not expected, it will discard the packet
and send an ACK packet for the last received packet. Since there is no ACK
packet that satifies those in the sender's window, the sender will know and
retransmit all the packets in the window.

![TCP GBN order](/tcp-gbn-order.png "TCP GBN order")

After reading this, you might wonder why GBN does not send only the ACK-missing
packet instead of all the packets in the window. The reason is that GBN does not
maintain a buffer to store packets in the receiver. The receiver only keeps
track of the expected sequence number. When the receiver receives an
out-of-order packet, it will discard the packet and send an ACK packet for the
last orderly-correct packet. A single error packet can make the sender resend
multiple packets, which is not efficient in terms of bandwidth and resource.

### Selective Repeat

**Selective Repeat (SR)** protocol is an improvement over GBN. As the name
suggests, SR allows the sender to retransmit only those packets that it
_suspects_ to be corrupted, or lost at the receiver. There are two main
differences between SR and GBN:

- SR allows the sender to maintain ACK'd packets that are not the first in the
  window. If the sender receives an ACK'd packet for the first packet in the
  window, it will simply advance the window.
- SR allows the receiver to maintain a sliding window of its own to buffer out-
  of-order packets. The receiver can send an ACK packet for each received
  packet in the window. When the receiver receives the first packets in the
  window, it will deliver the data to the application and advance the window to
  right.

With a sliding window to buffer out-of-order packets in the receiving end, both
sender and receiver can communicate with each other to determine which packets
are ACK'd and which packets are likely to be lost. But then, if the sender knows
some of the packets are lost, how does it retransmit?

Again, timeout is the key. Timers are used to protect against lost packets. But
instead of having one timer for all packets, the sender now maintains a timer
for each sent but not yet ACK'd packet. If the timer expires, the sender will
retransmit only the packets that are likely to be lost. The sender will not
retransmit the packets that are already ACK'd by the receiver.

![TCP SR operation](/tcp-sr-operation.png "TCP SR operation")

However, SR has its own drawbacks. First, maintaining multiple timers, one for
each packet, is not efficient. Secondly, there is no synchronization between the
the sender's window and the receiver's window. The sender can send packets
faster than the receiver can receive them. This can cause the receiver's buffer
to overflow and packets to be dropped. And if every packet is lost, SR will face
the same problem as GBN, i.e. the sender will retransmit all the packets in the
window.

### What does TCP use?

Both protocols for handling lost packets and out-of-order problems contain some
drawback that makes them not suitable for the real-world applications. Instead
of picking solely one of them, TCP uses a hybrid version of both protocols.

TCP implements another mechanism called **duplicate ACKs** to handle the lost
packets. When a TCP receiver gets packets out of order (e.g., packet 5 arrives
but packet 4 is missing), it sends an ACK for the last in-order packet it
successfully received (in this case, packet 3). If more out-of-order packets
arrive (say, packets 6 and 7), the receiver keeps sending the same ACK for
packet 3 repeatedly. These are called duplicate ACKs. Typically, TCP uses 3
duplicate ACKs as a threshold to trigger the retransmission of the missing
packet.

Beside that, TCP also implements a mechanism called **fast retransmit** to
retransmit the lost packets. When the sender receives 3 duplicate ACKs, it
will retransmit the missing packet without waiting for the timer to expire. This
is called fast retransmit because it allows the sender to retransmit the missing
packet before the timer expires. This mechanism is used to improve the
performance of TCP in networks with high packet loss.

TCP also uses a timer to retransmit the lost packets. However, the timer is used
in situations that duplicate ACKs are not likely to sent such as a congested
network, or the packet is the last packet in the window.

Mordern TCP implementations also use a mechanism called **selective
acknowledgment (SACK)** to improve the performance of TCP in networks with high
packet loss. SACK allows the receiver to inform the sender about all the packets
that are received successfully, not just the last in-order packet. This allows
the sender to retransmit only the missing packets, not all the packets in the
window.

![TCP SACK operation](/tcp-sack-operation.png "TCP SACK operation")

## Flow control

Flow control is a mechanism that prevents the sender from overwhelming the
receiver with too much data in a short time window. In practical networks,
senders often have one job to do, which is to construct and send data. On the
other hand, receivers have many jobs to fulfill such as receiving data.

For example, an HTTP message is sent from the client to the server to request
for a video. The client HTTP is relatively simple; it just sends the string text
as a GET request. However, the job at the server side is much more complex. The
server needs to read the request, parse it, find the video file by communicating
with database, read the file, encode it and send it back to the client. These
works take time and resources and might take delay to respond back to the
client. If a client sends multiple requests to the server while is still busy
doing something else, the requests will be buffered in the server. If the buffer
is full, it will cause an overflow and the server will drop the packets.

Flow control essentially is a feedback server that the receiver sends to the
sender and says "Hey, I can only handle this much data at a time. Can you
please match with it?". The sender will then adjust the sending rate to match
with the receiver's receiving rate.

Recalling both sender and receiver maintain a sliding window to keep track of
the packets that are sent and received. The following diagrams illustrate how
the sliding window works in the sender and receiver.

```txt disableCopyButton

                   1         2          3          4
              ----------|----------|----------|----------
                     SND.UNA    SND.NXT    SND.UNA
                                          +SND.WND

        1 - old sequence numbers which have been acknowledged
        2 - sequence numbers of unacknowledged data
        3 - sequence numbers allowed for new data transmission
        4 - future sequence numbers which are not yet allowed

                          Send Sequence Space
```

```txt
                       1          2          3
                   ----------|----------|----------
                          RCV.NXT    RCV.NXT
                                    +RCV.WND

        1 - old sequence numbers which have been acknowledged
        2 - sequence numbers allowed for new reception
        3 - future sequence numbers which are not yet allowed

                         Receive Sequence Space
```

Let's break down the terms used in the diagrams:

- **SND.UNA**: Unacknowledged sequence number of the first byte in the
  sender's window.
- **SND.NXT**: Next sequence number to be sent by the sender.
- **SND.WND**: Size of the sender's window.
- **RCV.NXT**: Next sequence number to be received by the receiver.
- **RCV.WND**: Size of the receiver's window.

The sender's window is the buffer TCP allocates to store the packets are sent.
However, the sender can only send bytes in the range of `SND.NEXT` to the right
edge of the window. The sender also needs to consult with `MSS` (maximum segment
size) to determine the final size of the window.

$$
\begin{equation}
\text{SND.WND} = \min(\text{MSS}, \text{SND.UNA} + \text{SND.WND} - \text{SND.NXT})
\end{equation}
$$

This allows the sender to utilize the buffer efficiently by sending as much data
as possible without overflowing the sender's buffer.

On the receiver side, the receiver also maintains a window to store the packets
that are received. Often, the receive window is pre-allocated by the operating
system, or more commonly, equal to the receive buffer.

The receiver's window is the buffer TCP allocates to store the packets that are
received. The receiver can only receive bytes in the range of `RCV.NXT` to the
right edge of the window.

If a packet arrives outside and on the left of the window, the receiver
considers the packet as a duplicate packet and discards it. If a packet arrives
outside and on the right of the window, the receiver considers the packet as an
out-of-order packet and also discards it because the system has not allocated
resource to process that packet yet.

If the receiving window is 0, which means there is no space to store the packet,
the receiver will send an ACK packet with the same sequence number as the last
received packet and advertise the window size to 0. The sender now enters **the
persist timer** state, which implements a timer that periodically sends a probe
packet of 1 byte to the receiver to check if the window is open. If the sender
continues to receive the ACK packet with the same sequence number and the window
size is still 0, the sender will continue the same process.

The window size is dynamic and can be adjusted by the receiver:

1. The window closes at the left edge when the receiver has acknowledged the
  packet.
2. The window opens at the right edge when the receiver process has finished
  processing other jobs and allocated resources to process incoming packets.
3. In rare cases, the window size shrinks when the the receiver closes at the
  right edge. [RFC 1122 Section 4.2.2.16](
  https://datatracker.ietf.org/doc/html/rfc1122#page-91) strongly
  discourages it because it might cause a _negative window_ on the sender size.

Here is the table that summarizes the flow control:

|  Time | Seg # | Sender: | Receiver | Action | Stored | Free |
|-------|-------|:--------:|:----------:|:--------:|--------|------|
| 0.000 | 1 | 1:1025(1024)| | | 1024 | 3072 |
| 0.002 | 2 | 1025:2049(1024) | | | 2048 | 2048 |
| 0.003 | 3 | 2049:3073(1024) | | | 3072 | 1024 |
| 0.005 | 4 | 3073:4097(1024) | | | 4096 | 0 |
| 0.170 | 5 | (persist timer) | ACK 4097, win 0 | | | |
| 3.990 | | | | read 256 | 3840 | 256 |
| 5.151 | 6 | 4097:4098(1) | | | 3840 | 256 |
| 5.990 | | | | read 256 | 3584 | 512 |
| 7.990 | | | | read 256 | 3328 | 768 |
| 9.990 | | | | read 256 | 3072 | 1024 |
| 10.15 | 8 | 4097:4098(1) | | | 3072 | 1024 |
| 10.17 | 9 | | ACK 4097, win 0 | | | |
| 11.99 | | | | read 256 | 2816 | 1280 |
| 13.99 | | | | read 256 | 2560 | 1536 |
| 15.15 | 10 | 4097:4098(1) | | | 2560 | 1536 |
| 15.17 | 11 | | ACK 4097, win 1536 | | | |
| 15.17 | 12 | 4097:5121(1024) | | | 3584 | 512 |
| 15.37 | 13 | | ACK 5121, win 512 | | | |
| 15.99 | | | | read 256 | 3328 | 768 |
| 17.99 | | | | read 256 | 3072 | 1024 |
| 19.99 | | | | read 256 | 2816 | 1280 |
| 20.15 | 14 | 5121:5633(512) | | | 3328 | 768 |
| 20.17 | 15 | (persist timer) | ACK 5633, win 0 | | |
| 21.99 | | | | read 256 | 3072 | 1024 |
| 23.99 | | | | read 256 | 2816 | 1280 |
| 25.15 | 16 | 5633:5634(1) | | | 2816 | 1280 |
| 25.17 | 17 | | ACK 5633, win 1280 | | | |
| 25.17 | 18 | 5633:6145(512) | | | 3328 | 768 |
| 25.20 | 19 | | ACK 6145, win 768 | | | |
| 25.99 | | | | read 256 | 3072 | 1024 |
| 27.99 | | | | read 256 | 2816 | 1280 |
| 29.99 | | | | read 256 | 2560 | 1536 |
| 31.99 | | | | read 256 | 2304 | 1792 |
| 33.99 | | | | read 256 | 2048 | 2048 |
| 35.99 | | | | read 256 | 1792 | 2304 |
| 37.99 | | | | read 256 | 1536 | 2560 |
| 39.99 | | | | read 256 | 1280 | 2816 |
| 40.00 | 20 | | ACK 8193, win 2816 | | | |
| 41.99 | | | | read 256 | 1024 | 3072 |
| 43.99 | | | | read 256 | 768 | 3328 |
| 45.99 | | | | read 256 | 512 | 3584 |
| 47.99 | | | | read 256 | 256 | 3840 |
| 49.99 | | | | read 256 | 0 | 4096 |
| 51.99 | | | | read 256 (EOF) | 0 | 4096 |
| 52.00 | 21 | | ACK 9473, win 4096 | | | |

## Congestion control

# Implement a TCP client and server

# Conclusion

[^1]: [Design, Modeling, and Implementation of Robust Migration of Stateful Edge Microservices](https://www.researchgate.net/publication/375562820_Design_Modeling_and_Implementation_of_Robust_Migration_of_Stateful_Edge_Microservices)


