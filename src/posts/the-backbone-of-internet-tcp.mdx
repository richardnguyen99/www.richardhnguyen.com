---
title: 'The Backbone of Internet: TCP'
slug: 'the-backbone-of-internet-tcp'
date: '2025-03-11'
published: false
publishedAt: '2025-03-11'
author: 'Richard H. Nguyen'
tags:
  - 'tcp'
  - 'network'
category: 'computer-network'
thumbnail: '/thumbnails/tcp.png'
changeLog:
  -
    date: '2024-09-30'
    changes:
      - 'Initial post'
  -
    date: '2025-03-11'
    changes:
      - 'Write the post'
---

Transmission Control Protocol (TCP) is one of the core protocols of the
Internet Protocol Suite. TCP provides reliable, ordered, and error-checked
delivery of content between two endpoints. It is the backbone of the Internet
and is used by many applications like web browsing, email, and file transfer.

{/* EXCERPT */}

# Introduction

TCP is one of the standard network protocols that define our modern Internet.
85% of total Internet traffic is TCP traffic[^1], while the rest is UDP traffic.
It was developed in the 1970s by
[Vint Cerf](https://www.internethalloffame.org/vint-cerf/) and
[Robert Kahn](https://www.internethalloffame.org/inductee/robert-kahn/)
to buildd a reliable client-server communication using
[packet-switching](https://ethw.org/Packet_Switching).

> Packet switching is a method of data transmission in which data is broken into
> small packets and sent over a network. Instead of establishing a dedicated
> connection line between two hosts, packet switching allows smaller packets to
> be sent independently on multiple routes and reassembled at the destination.

TCP is a connection-oriented, reliable, and stream-oriented protocol. It
provides many mechanisms to ensure the reliability of data transmission such as
error detection, retransmission, duplication, flow controls and congestion
controls.

Most of TCP applications are web-based applications like HTTP (HTTP/1.1 and
HTTP/2), HTTPS, FTP and SMTP, which are basically the protocols that run servers
and applications used by billions of people globally.

# What is TCP?

TCP is a protocol in the Transport Layer of the Internet Protocol Suite. The job
of the Transport Layer is to provide a logical communication between _application processes_. Transport Layer is implemented on top of the Network
Layer and below the Application Layer.

TCP and UDP are the two most common transport protocols. They are both
implemented by the operating systems in the endpoint devices such as computers,
smartphones, and servers whereas the Network Layer is implemented by the
routers and switches and the Application Layer is implemented by the
applications such as web browsers, and web servers.

> If you are not familiar with the network model, I have a post that explains it
> using a postal service analogy. You can read it
> [here](/blogs/understand-the-network-protocol-stacks-with-analogy).

As mentioned above, TCP is a reliable protocols for transferring data between
two endpoints. But why do we need a reliable protocol? Can we just send the data
and the other end will receive it? Well, it's not the simple. There are
many situations the can cause the data to be lost or corrupted during the
transmission. TCP is designed to handle these situations, ensure that the data is transferred correctly and in the right order.

## Connection-oriented protocol

TCP is a connection-oriented protocol because in order to transfer data, both
endpoints must establish a dedicated communication path before sending or
receiving any data. This is done by a process called
[three-way handshake](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment).

```mermaid
sequenceDiagram
    autonumber
    participant client
    participant server


    critical TCP establish from client
        client->>+server: (TCP) Send SYN
        server-->>-client: (TCP) send SYN & ACK
        client->>server: (TCP) Send ACK

        Note over client,server: Threeway handshake completed
    end

    client->>+server: Hello!
    server-->>-client: Hi!

    client->>+server: How are you?
    server-->>-client: I'm fine.<br/>And you?

    client->>+server: I'm good.
    server-->>-client: Good to hear!

    Note over client,server: Any data can be sent with<br />a reliable connection


    critical TCP close from server
        server->>+client: (TCP) Send FIN
        client-->>server: (TCP) send ACK
        client-->>-server: (TCP) send FIN
        server->>client: (TCP) send ACK

        Note over client,server: Threeway handshake completed
    end
```

To understand the connection-mode of TCP, you should consider how connectionless
protocols like UDP and IP work. UDP wraps the data in a packet, called
_datagram_, and sends it to the destination without any prior. It follows the
principle of "Fire and Forget". The sender does not care if the packet is
delivered or not. If it needs a response, it will either wait, send another
packet or respond back to the user.

TCP establishes a connection between two endpoints before transferring any data.
This connection will detect data corruption, correct errors and retransmit lost
data. It also ensures that the data is delivered in the same order as it was
sent.

## Reliable data transfer

TCP is built on top of the unreliable IP protocol. IP does not guarantee that
the data is delivered. It follows the principle of "Best Effort", i.e _"I try my
best but I don't promise anything"_. Due to physical factors, data can be
corrupted with bit flipping. And when you move higher to the architecture of the
Internet, data can be lost due to many reasons such as delay, network congestion
or simply the destination is unreachable.

For example, in a busy network, packets can be dropped due to congestion. In the
following figure, packet 1 and packet 3 got transferred successfully but packet
2 got dropped because host D is facing a congestion in its network.

![Packet Loss](/packet-loss.png "Packet Loss")

TCP provides many mechanisms to ensure that the data is transferred in whole and
in the right order. Not only that, TCP can detect and control the congestion
in the host and in the network with *flow control* and *congestion control*
mechanisms respectively.


## Stream-oriented protocol

TCP is a stream-oriented protocol. It means that it provides a continuous
stream of data between two endpoints. The data is divided into smaller chunks
called _segments_ and each segment is assigned a sequence number. The receiver
reassembles the segments in the correct order based on the sequence numbers.

For example, if the sender sends three segments with sequence numbers 1, 2 and
3, the receiver will receive them in the same order and reassemble them into
a continuous stream of data. The receiver will also send an acknowledgment
(ACK) packet to the sender to confirm that the segments are received correctly.

```mermaid
sequenceDiagram
    autonumber
    participant client
    participant server

    Note over client,server: Client sends a stream of data to the server

    client->>+server: (TCP) Send segment 1
    client->>+server: (TCP) Send segment 2
    client->>+server: (TCP) Send segment 3

    Note over client,server: Server receives the segments and reassembles<br />them into a continuous stream of data

    server-->>-client: (TCP) send ACK for segment 1
    server-->>-client: (TCP) send ACK for segment 2
    server-->>-client: (TCP) send ACK for segment 3

    Note over client,server: Client receives the ACK packets and<br />knows that the segments are received correctly
```

The following figure illustrates how TCP provides a continuous stream of data
between two endpoints. The sender sends a stream of data to the receiver and
the receiver reassembles the data into a continuous stream. The sender and
receiver use sequence numbers to keep track of the segments and ensure that
the data is delivered in the right order.

# How TCP works

TCP is a complex protocol because it has to handle many different situations
that can occur during data transmission and cause data loss or corruption. TCP
provides many mechanisms to ensure the reliability of data transmission such as
error detection, retransmission, duplication, flow controls and congestion
controls.

## Error detection

The most basic mechanism of a reliable data transfer (RDT) protocol is the error
detection mechanism. Let's grant that all the data is delivered to the receiver
in the correct order. But how do we know that the data is not corrupted?

There are many factors that can cause the data to be corrupted. It could be a
hardware problem such as faulty network devices, power surge or improper
shutdown. It could also be a software problem due to wrong configuration on the
network stacks, outdated drivers, etc.

TCP uses a checksum to detect errors in the data. This checksum is computed at
the sender side and sent along with the data. The receiver computes the checksum
of the received data and compares it with the checksum sent by the sender. If
the checksums match, the data is considered to be correct. If the checksums do
not match, the data is considered to be corrupted and the receiver will discard
the data.

But here is the tricky part. How should the receiver tell the sender that the
data is corrupted? The sender will be wait for the ACK packet from the receiver
to confirm that the data is received correctly.

The receiver can send a negative acknowledgment (NAK or NACK) packet to the
sender to indicate that an error is detected. The sender will retransmit the
data.

![TCP Receiver Error Detection](/tcp-receiver-error-detection.png "TCP Receiver Error Detection")

After sending the data, the sender will wait for the response packet from the
receiver. If the sender receives an ACK packet, it means that the data is
received correctly. If the sender receives a NACK packet, it means that the data
is corrupted and the sender will retransmit the data.

![TCP Sender Error Detection](/tcp-sender-error-detection.png "TCP Sender Error Detection")

However, the NACK mechanism is not used in TCP directly. Instead, the receiver
treats the corrupted data as a packet loss; it will discard the corrupted data.


## Packet loss and Packet retransmission

Same as data corruption, packet loss is another most common problem when it
comes to building a reliable data transfer protocol. There are many factors that
can cause packet loss such as queue overflow, congestion or just simply business
rules.

TCP is designed to handle packet loss and retransmit the lost packets. When a
packet is sent, the sender will expect an acknowledgment (ACK) packet from the
receiver to confirm that the packet is arrived safely. If the sender does not
receive the ACK packet that matches the sequence number of the sent packet, it
will assume that the packet is lost. The sender will retransmit the packet.

TCP uses a time-based retransmission mechanism to retransmit the lost packets.
When a packet is sent, the sender starts a timer. If the timer expires before
the sender receives the ACK packet, it will retransmit the packet.

![TCP timer retransmission](/tcp-timer-retransmission.png "TCP timer retransmission")

> From the perspective of Host A, it does not know whether the packet is lost
> before arriving at Host B, the packet gets dropped at Host B, the ACK packet
> from Host B is lost or there is a unusual delay. In all cases, the timer will
> act as a trigger to retransmit the packet.

However, relying on the timer is not an efficient way to handle packet loss. In
a practical network, sending packets, even when they are likely to be lost, are
still faster than waiting for the timer to expire. You don't know how long it's
gonna take for the timer to expire so it tends to be set with a high value.

## Pipelining and out-of-order delivery

Pipelining is a technique that allows multiple packets to be sent before
waiting for the acknowledgment (ACK) of the previous packets. This technique
increases the throughput of the network because it allows the sender to send
more packets in a shorter amount of time. However, it also increases the
complexity of the protocol because the receiver can receive the packets in any
order. The receiver must be able to reassemble the packets in the correct order
before delivering the data to the application.

### Go-Back-N

**Go-Back-N (GBN)** protocol allows the sender to send multiple requests within
available number  without waiting for the an acknowledgment package. Combining
with a timer, the sender can retransmit the lost packets.

In order to handle multiple concurrent packets, GBN senders maintain a sliding
window to buffer outgoing and incoming packets. A sliding window is a range of
sequence numbers and acknowledgments (ACKs) that the sender and receiver use to
keep track of the packets that are sent and received. The sender  to maintain
one timer for the first sent-but-not-yet-ACK'd packet.

![TCP sliding window in sender](/tcp-sender-window.png "TCP sliding window in sender")

In the figure, the sender is expecting ACKs for packets `n`, `n+1`, and `n+2`
ACK packets. If the sender receives an ACK packet for packet `n`, it will
advance the window to the right and the timer will be reset until there is none
sent-but-not-yet-ACK'd packets.

The sender uses the timer to keep track of the first ACK packet in the window.
If the timer expires, the sender will retransmit all the packets.

![TCP GBN retransmission](/tcp-gbn-retransmission.png "TCP GBN retransmission")

On the receiver side, its job is to keep the order of the received packets. The
receiver maintains a global next-expected sequence number. When the receiver
receives a packet with the expected sequence number, it will deliver the data to
the application and send an ACK packet to the sender. If the receiver receives a
packet with a sequence number that is not expected, it will discard the packet
and send an ACK packet for the last received packet. Since there is no ACK
packet that satifies those in the sender's window, the sender will know and
retransmit all the packets in the window.

![TCP GBN order](/tcp-gbn-order.png "TCP GBN order")

After reading this, you might wonder why GBN does not send only the ACK-missing
packet instead of all the packets in the window. The reason is that GBN does not
maintain a buffer to store packets in the receiver. The receiver only keeps
track of the expected sequence number. When the receiver receives an
out-of-order packet, it will discard the packet and send an ACK packet for the
last orderly-correct packet. A single error packet can make the sender resend
multiple packets, which is not efficient in terms of bandwidth and resource.

### Selective Repeat

**Selective Repeat (SR)** protocol is an improvement over GBN. As the name
suggests, SR allows the sender to retransmit only those packets that it
_suspects_ to be corrupted, or lost at the receiver. There are two main
differences between SR and GBN:

- SR allows the sender to maintain ACK'd packets that are not the first in the
  window. If the sender receives an ACK'd packet for the first packet in the
  window, it will simply advance the window.
- SR allows the receiver to maintain a sliding window of its own to buffer out-
  of-order packets. The receiver can send an ACK packet for each received
  packet in the window. When the receiver receives the first packets in the
  window, it will deliver the data to the application and advance the window to
  right.

With a sliding window to buffer out-of-order packets in the receiving end, both
sender and receiver can communicate with each other to determine which packets
are ACK'd and which packets are likely to be lost. But then, if the sender knows
some of the packets are lost, how does it retransmit?

Again, timeout is the key. Timers are used to protect against lost packets. But
instead of having one timer for all packets, the sender now maintains a timer
for each sent but not yet ACK'd packet. If the timer expires, the sender will
retransmit only the packets that are likely to be lost. The sender will not
retransmit the packets that are already ACK'd by the receiver.

![TCP SR operation](/tcp-sr-operation.png "TCP SR operation")

However, SR has its own drawbacks. First, maintaining multiple timers, one for
each packet, is not efficient. Secondly, there is no synchronization between the
the sender's window and the receiver's window. The sender can send packets
faster than the receiver can receive them. This can cause the receiver's buffer
to overflow and packets to be dropped. And if every packet is lost, SR will face
the same problem as GBN, i.e. the sender will retransmit all the packets in the
window.

### What does TCP use?

Both protocols for handling lost packets and out-of-order problems contain some
drawback that makes them not suitable for the real-world applications. Instead
of picking solely one of them, TCP uses a hybrid version of both protocols.

TCP implements another mechanism called **duplicate ACKs** to handle the lost
packets. When a TCP receiver gets packets out of order (e.g., packet 5 arrives
but packet 4 is missing), it sends an ACK for the last in-order packet it
successfully received (in this case, packet 3). If more out-of-order packets
arrive (say, packets 6 and 7), the receiver keeps sending the same ACK for
packet 3 repeatedly. These are called duplicate ACKs. Typically, TCP uses 3
duplicate ACKs as a threshold to trigger the retransmission of the missing
packet.

Beside that, TCP also implements a mechanism called **fast retransmit** to
retransmit the lost packets. When the sender receives 3 duplicate ACKs, it
will retransmit the missing packet without waiting for the timer to expire. This
is called fast retransmit because it allows the sender to retransmit the missing
packet before the timer expires. This mechanism is used to improve the
performance of TCP in networks with high packet loss.

TCP also uses a timer to retransmit the lost packets. However, the timer is used
in situations that duplicate ACKs are not likely to sent such as a congested
network, or the packet is the last packet in the window.

Mordern TCP implementations also use a mechanism called **selective
acknowledgment (SACK)** to improve the performance of TCP in networks with high
packet loss. SACK allows the receiver to inform the sender about all the packets
that are received successfully, not just the last in-order packet. This allows
the sender to retransmit only the missing packets, not all the packets in the
window.

![TCP SACK operation](/tcp-sack-operation.png "TCP SACK operation")

## Flow control

## Congestion control

# Implement a TCP client and server

# Conclusion

[^1]: [Design, Modeling, and Implementation of Robust Migration of Stateful Edge Microservices](https://www.researchgate.net/publication/375562820_Design_Modeling_and_Implementation_of_Robust_Migration_of_Stateful_Edge_Microservices)


